export const __esModule: boolean;
export class OCRService {
    constructor(prisma: any, logger: any, kafkaService: any);
    prisma: any;
    logger: any;
    kafkaService: any;
    mlModels: Map<any, any>;
    supportedLanguages: Set<DocumentManagement_1.Language>;
    processingQueue: Map<any, any>;
    performOCR(request: any): Promise<({
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: any;
        words: any;
        lines: any;
        paragraphs: any;
        regions: {
            text: any;
            confidence: number;
            paragraphs: any;
            boundingBox: {
                x: number;
                y: number;
                width: any;
                height: any;
            };
        }[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    } | {
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any;
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    })[]>;
    processPage(filePath: any, pageNumber: any, request: any): Promise<{
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: any;
        words: any;
        lines: any;
        paragraphs: any;
        regions: {
            text: any;
            confidence: number;
            paragraphs: any;
            boundingBox: {
                x: number;
                y: number;
                width: any;
                height: any;
            };
        }[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    } | {
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any;
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    }>;
    processTesseractOCR(filePath: any, pageNumber: any, request: any): Promise<{
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: any;
        words: any;
        lines: any;
        paragraphs: any;
        regions: {
            text: any;
            confidence: number;
            paragraphs: any;
            boundingBox: {
                x: number;
                y: number;
                width: any;
                height: any;
            };
        }[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    }>;
    processAWSTextract(filePath: any, pageNumber: any, request: any): Promise<{
        id: string;
        documentId: any;
        pageNumber: any;
        text: string;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any[];
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    }>;
    processGoogleVision(filePath: any, pageNumber: any, request: any): Promise<{
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any;
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    }>;
    processAzureCognitive(filePath: any, pageNumber: any, request: any): Promise<{
        id: string;
        documentId: any;
        pageNumber: any;
        text: string;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any[];
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    }>;
    processCustomML(filePath: any, pageNumber: any, request: any): Promise<{
        id: string;
        documentId: any;
        pageNumber: any;
        text: string;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any[];
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    }>;
    preprocessImage(filePath: any, options: any): Promise<string>;
    postprocessOCRResult(result: any, options: any): Promise<void>;
    performSpellCheck(text: any, language: any): Promise<any>;
    applyLanguageModel(text: any, language: any): Promise<any>;
    performContextualCorrection(text: any): Promise<any>;
    removeNoiseCharacters(text: any): any;
    formatText(text: any): any;
    recalculateConfidence(result: any): number;
    convertTesseractToOCRResult(data: any, documentId: any, pageNumber: any, language: any): {
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: any;
        words: any;
        lines: any;
        paragraphs: any;
        regions: {
            text: any;
            confidence: number;
            paragraphs: any;
            boundingBox: {
                x: number;
                y: number;
                width: any;
                height: any;
            };
        }[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    };
    convertTextractToOCRResult(data: any, documentId: any, pageNumber: any): {
        id: string;
        documentId: any;
        pageNumber: any;
        text: string;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any[];
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    };
    convertTextractBoundingBox(bbox: any): {
        x: any;
        y: any;
        width: any;
        height: any;
    };
    convertGoogleVisionToOCRResult(data: any, documentId: any, pageNumber: any): {
        id: string;
        documentId: any;
        pageNumber: any;
        text: any;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any;
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    };
    convertGoogleVisionBoundingBox(boundingPoly: any): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    convertAzureCognitiveToOCRResult(data: any, documentId: any, pageNumber: any): {
        id: string;
        documentId: any;
        pageNumber: any;
        text: string;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any[];
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    };
    convertAzureBoundingBox(bbox: any): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    convertMLPredictionToOCRResult(predictions: any, documentId: any, pageNumber: any, modelConfig: any): {
        id: string;
        documentId: any;
        pageNumber: any;
        text: string;
        confidence: number;
        language: DocumentManagement_1.Language;
        words: any[];
        lines: any[];
        paragraphs: any[];
        regions: any[];
        processingTime: number;
        ocrEngine: string;
        ocrVersion: string;
        createdAt: Date;
    };
    decodePredictions(predictions: any, modelConfig: any): string;
    mapToTesseractLanguage(language: any): any;
    mapFromTesseractLanguage(tesseractLang: any): any;
    initializeMLModels(): Promise<void>;
    createProcessingJob(request: any): Promise<{
        id: string;
        documentId: any;
        tenantId: any;
        jobType: string;
        status: DocumentManagement_1.ProcessingStatus;
        priority: string;
        progress: number;
        retryCount: number;
        maxRetries: number;
        configuration: {
            engine: any;
            language: any;
            enablePreprocessing: any;
            enablePostProcessing: any;
        };
        createdAt: Date;
        updatedAt: Date;
    }>;
    updateJobStatus(jobId: any, status: any, results: any): Promise<void>;
    updateJobProgress(jobId: any, progress: any): Promise<void>;
    getDocument(documentId: any, tenantId: any): Promise<{
        id: any;
        tenantId: any;
        pageCount: number;
    }>;
    storeOCRResults(results: any): Promise<void>;
    publishOCRCompletedEvent(documentId: any, tenantId: any, results: any): Promise<void>;
}
import DocumentManagement_1 = require("../../models/documentManagement/DocumentManagement");
