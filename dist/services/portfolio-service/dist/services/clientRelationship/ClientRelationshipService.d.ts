export const __esModule: boolean;
export class ClientRelationshipService {
    constructor(kafkaService: any);
    prisma: import(".prisma/client").PrismaClient<import(".prisma/client").Prisma.PrismaClientOptions, never, library_1.DefaultArgs>;
    kafkaService: any;
    createClientProfile(tenantId: any, request: any, userId: any): Promise<{
        client: {
            id: `${string}-${string}-${string}-${string}-${string}`;
            tenantId: any;
            clientNumber: string;
            clientType: any;
            status: ClientRelationship_1.ClientStatus;
            firstName: any;
            lastName: any;
            entityName: any;
            email: any;
            phoneNumber: any;
            primaryAddress: any;
            investmentObjectives: any;
            riskTolerance: any;
            investmentExperience: any;
            liquidityNeeds: any;
            timeHorizon: any;
            investmentRestrictions: any;
            documentDeliveryPreference: any;
            communicationPreferences: any;
            politicallyExposedPerson: boolean;
            employeeOfBrokerDealer: boolean;
            directorOfPublicCompany: boolean;
            assignedTeam: any[];
            relationshipStartDate: Date;
            createdAt: Date;
            updatedAt: Date;
            createdBy: any;
            updatedBy: any;
        };
        totalAssets: library_1.Decimal;
    }>;
    getClientProfile(clientId: any, tenantId: any): Promise<{
        client: {
            id: string;
            tenantId: string;
            clientNumber: string;
            clientType: import(".prisma/client").$Enums.ClientType;
            status: import(".prisma/client").$Enums.ClientStatus;
            firstName: string;
            lastName: string;
            middleName: string;
            entityName: string;
            dateOfBirth: Date;
            socialSecurityNumber: string;
            taxId: string;
            email: string;
            phoneNumber: string;
            mobileNumber: string;
            primaryAddress: {
                id: string;
                country: string;
                clientId: string;
                state: string;
                street1: string;
                street2: string | null;
                city: string;
                postalCode: string;
                isPrimary: boolean;
            } | {
                street1: string;
                city: string;
                state: string;
                postalCode: string;
                country: string;
                isPrimary: true;
            };
            investmentObjectives: {
                id: string;
                objective: string;
                priority: number;
                targetAllocation: library_1.Decimal;
                description: string;
            }[];
            riskTolerance: import(".prisma/client").$Enums.RiskTolerance;
            investmentExperience: import(".prisma/client").$Enums.InvestmentExperience;
            liquidityNeeds: import(".prisma/client").$Enums.LiquidityNeeds;
            timeHorizon: number;
            netWorth: library_1.Decimal;
            annualIncome: library_1.Decimal;
            liquidNetWorth: library_1.Decimal;
            investmentExperienceYears: number;
            investmentRestrictions: {
                id: string;
                restrictionType: string;
                description: string;
                appliesTo: string;
                isActive: boolean;
                effectiveDate: Date;
                expirationDate: Date;
            }[];
            documentDeliveryPreference: import(".prisma/client").$Enums.DocumentDeliveryPreference;
            communicationPreferences: {
                method: import(".prisma/client").$Enums.CommunicationMethod;
                frequency: string;
                timePreference: string;
                isPreferred: boolean;
            }[];
            politicallyExposedPerson: boolean;
            employeeOfBrokerDealer: boolean;
            directorOfPublicCompany: boolean;
            primaryAdvisor: string;
            assignedTeam: string[];
            relationshipStartDate: Date;
            lastContactDate: Date;
            createdAt: Date;
            updatedAt: Date;
            createdBy: string;
            updatedBy: string;
        };
        portfolios: any[];
        totalAssets: library_1.Decimal;
        householdInfo: any;
    }>;
    updateClientProfile(clientId: any, tenantId: any, updates: any, userId: any): Promise<{
        client: {
            id: string;
            tenantId: string;
            clientNumber: string;
            clientType: import(".prisma/client").$Enums.ClientType;
            status: import(".prisma/client").$Enums.ClientStatus;
            firstName: string;
            lastName: string;
            middleName: string;
            entityName: string;
            dateOfBirth: Date;
            socialSecurityNumber: string;
            taxId: string;
            email: string;
            phoneNumber: string;
            mobileNumber: string;
            primaryAddress: {
                id: string;
                country: string;
                clientId: string;
                state: string;
                street1: string;
                street2: string | null;
                city: string;
                postalCode: string;
                isPrimary: boolean;
            } | {
                street1: string;
                city: string;
                state: string;
                postalCode: string;
                country: string;
                isPrimary: true;
            };
            investmentObjectives: {
                id: string;
                objective: string;
                priority: number;
                targetAllocation: library_1.Decimal;
                description: string;
            }[];
            riskTolerance: import(".prisma/client").$Enums.RiskTolerance;
            investmentExperience: import(".prisma/client").$Enums.InvestmentExperience;
            liquidityNeeds: import(".prisma/client").$Enums.LiquidityNeeds;
            timeHorizon: number;
            netWorth: library_1.Decimal;
            annualIncome: library_1.Decimal;
            liquidNetWorth: library_1.Decimal;
            investmentExperienceYears: number;
            investmentRestrictions: {
                id: string;
                restrictionType: string;
                description: string;
                appliesTo: string;
                isActive: boolean;
                effectiveDate: Date;
                expirationDate: Date;
            }[];
            documentDeliveryPreference: import(".prisma/client").$Enums.DocumentDeliveryPreference;
            communicationPreferences: {
                method: import(".prisma/client").$Enums.CommunicationMethod;
                frequency: string;
                timePreference: string;
                isPreferred: boolean;
            }[];
            politicallyExposedPerson: boolean;
            employeeOfBrokerDealer: boolean;
            directorOfPublicCompany: boolean;
            primaryAdvisor: string;
            assignedTeam: string[];
            relationshipStartDate: Date;
            lastContactDate: Date;
            createdAt: Date;
            updatedAt: Date;
            createdBy: string;
            updatedBy: string;
        };
        portfolios: any[];
        totalAssets: library_1.Decimal;
        householdInfo: any;
    }>;
    createOnboardingWorkflow(clientId: any, tenantId: any, userId: any): Promise<{
        id: `${string}-${string}-${string}-${string}-${string}`;
        clientId: any;
        tenantId: any;
        workflowTemplate: string;
        status: ClientRelationship_1.OnboardingStatus;
        currentStep: number;
        totalSteps: number;
        steps: {
            stepNumber: number;
            stepName: string;
            description: string;
            isRequired: boolean;
            isCompleted: boolean;
            requiredDocuments: string[];
            requiredActions: string[];
            dependsOnSteps: number[];
            estimatedDuration: number;
        }[];
        startedDate: Date;
        estimatedCompletionDate: Date;
        assignedAdvisor: any;
        assignedTeam: any[];
        createdAt: Date;
        updatedAt: Date;
        createdBy: any;
        updatedBy: any;
    }>;
    updateOnboardingStep(workflowId: any, stepNumber: any, tenantId: any, userId: any, notes: any): Promise<{}>;
    createSuitabilityAssessment(request: any, tenantId: any, userId: any): Promise<{
        id: `${string}-${string}-${string}-${string}-${string}`;
        clientId: any;
        tenantId: any;
        assessmentDate: Date;
        assessmentType: any;
        riskTolerance: any;
        riskCapacity: string;
        investmentObjectives: any;
        timeHorizon: any;
        liquidityNeeds: any;
        netWorth: any;
        annualIncome: any;
        investmentExperience: any;
        overallScore: number;
        riskScore: number;
        objectiveAlignment: number;
        recommendedAllocation: {
            assetClass: string;
            targetPercentage: library_1.Decimal;
            rationale: string;
        }[];
        unsuitableInvestments: string[];
        reviewedBy: any;
        reviewDate: Date;
        nextReviewDate: Date;
        createdAt: Date;
        updatedAt: Date;
        createdBy: any;
    }>;
    scheduleMeeting(request: any, tenantId: any, userId: any): Promise<{
        id: `${string}-${string}-${string}-${string}-${string}`;
        clientId: any;
        tenantId: any;
        meetingType: any;
        title: any;
        scheduledDate: any;
        duration: any;
        location: any;
        isVirtual: any;
        virtualMeetingLink: any;
        advisors: any;
        clients: any;
        agenda: any;
        actionItems: any[];
        followUpRequired: boolean;
        status: string;
        createdAt: Date;
        updatedAt: Date;
        createdBy: any;
        updatedBy: any;
    }>;
    recordCommunication(request: any, tenantId: any, userId: any): Promise<{
        id: `${string}-${string}-${string}-${string}-${string}`;
        clientId: any;
        tenantId: any;
        communicationType: any;
        subject: any;
        content: any;
        direction: any;
        contactedBy: any;
        contactedAt: Date;
        followUpRequired: any;
        followUpDate: any;
        category: any;
        priority: any;
        attachments: any[];
        createdAt: Date;
        createdBy: any;
    }>;
    getClientAnalytics(clientId: any, tenantId: any): Promise<{
        clientId: any;
        portfolioCount: number;
        totalAssets: library_1.Decimal;
        assetAllocation: {
            assetClass: string;
            targetPercentage: library_1.Decimal;
            rationale: string;
        }[];
        performanceMetrics: {
            ytdReturn: library_1.Decimal;
            oneYearReturn: library_1.Decimal;
            threeYearReturn: library_1.Decimal;
            inceptionReturn: library_1.Decimal;
            volatility: library_1.Decimal;
            sharpeRatio: library_1.Decimal;
        };
        riskMetrics: {
            valueAtRisk: library_1.Decimal;
            trackingError: library_1.Decimal;
            beta: library_1.Decimal;
            correlation: library_1.Decimal;
        };
        activitySummary: {
            lastTradeDate: Date;
            tradesYtd: number;
            lastMeetingDate: Date;
            nextMeetingDate: Date;
            lastContactDate: Date;
        };
    }>;
    getClientSegmentation(tenantId: any): Promise<({
        segmentName: string;
        criteria: {
            minAssets: library_1.Decimal;
            clientType: ClientRelationship_1.ClientType[];
            maxAssets?: undefined;
            riskTolerance?: undefined;
        };
        clientCount: number;
        totalAssets: library_1.Decimal;
        averageAssets: library_1.Decimal;
    } | {
        segmentName: string;
        criteria: {
            minAssets: library_1.Decimal;
            maxAssets: library_1.Decimal;
            clientType: ClientRelationship_1.ClientType[];
            riskTolerance?: undefined;
        };
        clientCount: number;
        totalAssets: library_1.Decimal;
        averageAssets: library_1.Decimal;
    } | {
        segmentName: string;
        criteria: {
            riskTolerance: ClientRelationship_1.RiskTolerance[];
            minAssets?: undefined;
            clientType?: undefined;
            maxAssets?: undefined;
        };
        clientCount: number;
        totalAssets: library_1.Decimal;
        averageAssets: library_1.Decimal;
    })[]>;
    generateClientNumber(tenantId: any): Promise<string>;
    getStandardOnboardingSteps(): {
        stepNumber: number;
        stepName: string;
        description: string;
        isRequired: boolean;
        isCompleted: boolean;
        requiredDocuments: string[];
        requiredActions: string[];
        dependsOnSteps: number[];
        estimatedDuration: number;
    }[];
    createInitialSuitabilityAssessment(clientId: any, tenantId: any, request: any, userId: any): Promise<{
        id: `${string}-${string}-${string}-${string}-${string}`;
        clientId: any;
        tenantId: any;
        assessmentDate: Date;
        assessmentType: any;
        riskTolerance: any;
        riskCapacity: string;
        investmentObjectives: any;
        timeHorizon: any;
        liquidityNeeds: any;
        netWorth: any;
        annualIncome: any;
        investmentExperience: any;
        overallScore: number;
        riskScore: number;
        objectiveAlignment: number;
        recommendedAllocation: {
            assetClass: string;
            targetPercentage: library_1.Decimal;
            rationale: string;
        }[];
        unsuitableInvestments: string[];
        reviewedBy: any;
        reviewDate: Date;
        nextReviewDate: Date;
        createdAt: Date;
        updatedAt: Date;
        createdBy: any;
    }>;
    calculateRiskCapacity(netWorth: any, annualIncome: any): "HIGH" | "LOW" | "MODERATE";
    calculateSuitabilityScore(request: any): number;
    calculateRiskScore(riskTolerance: any, netWorth: any): number;
    calculateObjectiveAlignment(objectives: any): 85 | 50;
    generateRecommendedAllocation(request: any): {
        assetClass: string;
        targetPercentage: library_1.Decimal;
        rationale: string;
    }[];
    identifyUnsuitableInvestments(request: any): string[];
    completeOnboarding(workflowId: any, tenantId: any, userId: any): Promise<void>;
    sendMeetingInvites(meeting: any): Promise<void>;
    updateLastContactDate(clientId: any, tenantId: any): Promise<void>;
    getClientPortfolios(clientId: any, tenantId: any): Promise<any[]>;
    calculateTotalAssets(clientId: any, tenantId: any): Promise<library_1.Decimal>;
    getHouseholdInfo(clientId: any, tenantId: any): Promise<any>;
}
import library_1 = require("@prisma/client/runtime/library");
import ClientRelationship_1 = require("../../models/clientRelationship/ClientRelationship");
