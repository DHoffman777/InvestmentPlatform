export const __esModule: boolean;
export class CreditRiskMonitoringService {
    constructor(prisma: any, kafkaProducer: any, customLogger: any);
    prisma: any;
    kafkaProducer: any;
    logger: any;
    assessCreditRisk(request: any): Promise<{
        id: string;
        portfolioId: any;
        tenantId: any;
        assessmentDate: Date;
        asOfDate: any;
        totalCreditExposure: any;
        averageCreditRating: string;
        investmentGradePercentage: number;
        highYieldPercentage: number;
        unratedPercentage: number;
        creditExposures: {
            id: string;
            securityId: any;
            issuerName: any;
            issuerId: any;
            sector: any;
            industry: any;
            country: any;
            currency: any;
            marketValue: any;
            notionalAmount: any;
            exposurePercentage: number;
            creditRating: any;
            maturityDate: any;
            duration: any;
            convexity: any;
            yieldToMaturity: any;
            creditSpread: any;
            defaultProbability: any;
            recoveryRate: any;
            lossGivenDefault: number;
            expectedLoss: number;
            unexpectedLoss: number;
            riskWeight: any;
            isInvestmentGrade: boolean;
            daysToMaturity: number;
            modifiedDuration: any;
        }[];
        sectorConcentration: {
            sector: any;
            totalExposure: any;
            exposurePercentage: number;
            numberOfIssuers: any;
            averageCreditRating: string;
            riskLevel: string;
        }[];
        counterpartyRisks: {
            issuerId: any;
            issuerName: any;
            totalExposure: any;
            numberOfPositions: any;
            averageCreditRating: string;
            sector: any;
            country: any;
            defaultProbability: any;
            expectedLoss: any;
            riskLevel: string;
            lastRatingChange: any;
            watchlistStatus: string;
        }[];
        creditMetrics: {
            totalCreditExposure: any;
            numberOfIssuers: number;
            averageCreditRating: string;
            averageMaturity: number;
            averageDuration: any;
            concentrationIndex: any;
            diversificationRatio: number;
            investmentGradePercentage: number;
            highYieldPercentage: number;
            unratedPercentage: number;
            averageDefaultProbability: any;
            portfolioSpread: any;
            modifiedDuration: any;
            creditBeta: number;
            trackingError: number;
        };
        migrationAnalysis: {
            matrix: {};
            timeHorizon: string;
            migrationProbabilities: {};
            expectedRatingChanges: {};
            downgradeProbability: number;
            upgradeProbability: number;
            stableRatingProbability: number;
        };
        creditVaR: {
            confidenceLevel: any;
            timeHorizon: any;
            creditVaR: number;
            marginalVaR: any[];
            componentVaR: any[];
            diversificationBenefit: number;
            expectedShortfall: number;
            simulationCount: number;
            modelType: string;
            calculationDate: Date;
        };
        expectedLosses: {
            securityId: any;
            issuerName: any;
            expectedLoss: number;
            probabilityOfDefault: any;
            lossGivenDefault: any;
            exposureAtDefault: any;
            timeHorizon: string;
            riskContribution: number;
        }[];
        unexpectedLosses: {
            securityId: any;
            issuerName: any;
            unexpectedLoss: number;
            lossVolatility: number;
            riskContribution: number;
            diversificationBenefit: number;
        }[];
        creditSpreads: {
            securityId: any;
            issuerName: any;
            currentSpread: any;
            averageSpread: number;
            spreadVolatility: number;
            percentileRank: number;
            zScore: number;
            trendDirection: string;
            sector: any;
            creditRating: any;
        }[];
        alerts: {
            id: string;
            type: string;
            severity: string;
            message: string;
            description: string;
            threshold: number;
            currentValue: any;
            recommendedAction: string;
            createdAt: Date;
        }[];
        recommendations: {
            id: string;
            type: string;
            priority: string;
            title: string;
            description: string;
            actions: string[];
            expectedImpact: string;
            implementationTimeframe: string;
        }[];
        riskLevel: string;
        calculationTime: number;
        createdAt: Date;
        assessedBy: any;
    }>;
    getPortfolioData(portfolioId: any, asOfDate: any): Promise<any>;
    calculateCreditExposures(portfolioData: any): Promise<{
        id: string;
        securityId: any;
        issuerName: any;
        issuerId: any;
        sector: any;
        industry: any;
        country: any;
        currency: any;
        marketValue: any;
        notionalAmount: any;
        exposurePercentage: number;
        creditRating: any;
        maturityDate: any;
        duration: any;
        convexity: any;
        yieldToMaturity: any;
        creditSpread: any;
        defaultProbability: any;
        recoveryRate: any;
        lossGivenDefault: number;
        expectedLoss: number;
        unexpectedLoss: number;
        riskWeight: any;
        isInvestmentGrade: boolean;
        daysToMaturity: number;
        modifiedDuration: any;
    }[]>;
    analyzeSectorConcentration(exposures: any): Promise<{
        sector: any;
        totalExposure: any;
        exposurePercentage: number;
        numberOfIssuers: any;
        averageCreditRating: string;
        riskLevel: string;
    }[]>;
    assessCounterpartyRisks(exposures: any): Promise<{
        issuerId: any;
        issuerName: any;
        totalExposure: any;
        numberOfPositions: any;
        averageCreditRating: string;
        sector: any;
        country: any;
        defaultProbability: any;
        expectedLoss: any;
        riskLevel: string;
        lastRatingChange: any;
        watchlistStatus: string;
    }[]>;
    calculateCreditMetrics(exposures: any, request: any): Promise<{
        totalCreditExposure: any;
        numberOfIssuers: number;
        averageCreditRating: string;
        averageMaturity: number;
        averageDuration: any;
        concentrationIndex: any;
        diversificationRatio: number;
        investmentGradePercentage: number;
        highYieldPercentage: number;
        unratedPercentage: number;
        averageDefaultProbability: any;
        portfolioSpread: any;
        modifiedDuration: any;
        creditBeta: number;
        trackingError: number;
    }>;
    performMigrationAnalysis(exposures: any): Promise<{
        matrix: {};
        timeHorizon: string;
        migrationProbabilities: {};
        expectedRatingChanges: {};
        downgradeProbability: number;
        upgradeProbability: number;
        stableRatingProbability: number;
    }>;
    calculateCreditVaR(exposures: any, request: any): Promise<{
        confidenceLevel: any;
        timeHorizon: any;
        creditVaR: number;
        marginalVaR: any[];
        componentVaR: any[];
        diversificationBenefit: number;
        expectedShortfall: number;
        simulationCount: number;
        modelType: string;
        calculationDate: Date;
    }>;
    calculateExpectedLosses(exposures: any): Promise<{
        securityId: any;
        issuerName: any;
        expectedLoss: number;
        probabilityOfDefault: any;
        lossGivenDefault: any;
        exposureAtDefault: any;
        timeHorizon: string;
        riskContribution: number;
    }[]>;
    calculateUnexpectedLosses(exposures: any, creditVaR: any): Promise<{
        securityId: any;
        issuerName: any;
        unexpectedLoss: number;
        lossVolatility: number;
        riskContribution: number;
        diversificationBenefit: number;
    }[]>;
    analyzeCreditSpreads(exposures: any): Promise<{
        securityId: any;
        issuerName: any;
        currentSpread: any;
        averageSpread: number;
        spreadVolatility: number;
        percentileRank: number;
        zScore: number;
        trendDirection: string;
        sector: any;
        creditRating: any;
    }[]>;
    generateCreditRiskAlerts(metrics: any, creditVaR: any, expectedLosses: any): Promise<{
        id: string;
        type: string;
        severity: string;
        message: string;
        description: string;
        threshold: number;
        currentValue: any;
        recommendedAction: string;
        createdAt: Date;
    }[]>;
    generateRecommendations(metrics: any, alerts: any): Promise<{
        id: string;
        type: string;
        priority: string;
        title: string;
        description: string;
        actions: string[];
        expectedImpact: string;
        implementationTimeframe: string;
    }[]>;
    hasCreditRisk(security: any): boolean;
    getCreditRating(security: any): any;
    getCurrentCreditSpread(security: any): Promise<any>;
    calculateDefaultProbability(security: any): Promise<any>;
    getRecoveryRate(security: any): Promise<any>;
    calculateLossGivenDefault(security: any): number;
    calculateRiskWeight(security: any): any;
    isInvestmentGrade(security: any): boolean;
    calculateDaysToMaturity(maturityDate: any): number;
    calculateTotalExposure(exposures: any): any;
    calculateAverageRating(exposures: any): string;
    calculateInvestmentGradePercentage(exposures: any): number;
    calculateHighYieldPercentage(exposures: any): number;
    calculateUnratedPercentage(exposures: any): number;
    determineOverallRiskLevel(metrics: any, alerts: any): "HIGH" | "MEDIUM" | "LOW";
    calculateWeightedAverageRating(exposures: any): string;
    calculateAverageMaturity(exposures: any): number;
    calculateAverageDuration(exposures: any): any;
    calculateConcentrationIndex(exposures: any): any;
    calculateDiversificationRatio(exposures: any): number;
    storeAssessment(assessment: any): Promise<void>;
    getCreditMigrationMatrix(): Promise<{}>;
    calculateMigrationProbabilities(exposures: any, matrix: any): {};
    calculateExpectedRatingChanges(exposures: any, probabilities: any): {};
    calculateDowngradeProbability(probabilities: any): number;
    calculateUpgradeProbability(probabilities: any): number;
    calculateStableRatingProbability(probabilities: any): number;
    runCreditVaRSimulations(exposures: any, confidenceLevel: any, timeHorizon: any): Promise<{
        creditVaR: number;
        marginalVaR: any[];
        componentVaR: any[];
        diversificationBenefit: number;
        expectedShortfall: number;
        count: number;
    }>;
    calculateLossVariance(exposure: any): number;
    calculateDiversificationBenefit(exposure: any, allExposures: any): number;
    getHistoricalSpreads(securityId: any): Promise<any[]>;
    calculateAverageSpread(spreads: any): number;
    calculateSpreadVolatility(spreads: any): number;
    calculateSpreadPercentile(current: any, historical: any): number;
    calculateSpreadZScore(current: any, historical: any): number;
    calculateSpreadTrend(spreads: any): "STABLE" | "WIDENING" | "TIGHTENING";
    calculateSectorAverageRating(exposures: any, sector: any): string;
    determineSectorRiskLevel(concentrationRatio: any): "HIGH" | "MEDIUM" | "LOW";
    calculateAverageRatingForExposures(exposures: any): string;
    calculateIssuerDefaultProbability(exposure: any): Promise<any>;
    determineCounterpartyRiskLevel(exposure: any, rating: any): "HIGH" | "MEDIUM" | "LOW";
    getLastRatingChange(issuerId: any): Promise<any>;
    getWatchlistStatus(issuerId: any): Promise<string>;
    calculateAverageDefaultProbability(exposures: any): any;
    calculatePortfolioSpread(exposures: any): any;
    calculatePortfolioModifiedDuration(exposures: any): any;
    calculateCreditBeta(exposures: any): Promise<number>;
    calculateTrackingError(exposures: any, benchmarkId: any): Promise<number>;
}
