export const __esModule: boolean;
export class DerivativesAnalyticsService {
    constructor(prisma: any, kafkaService: any);
    prisma: any;
    kafkaService: any;
    calculateGreeks(request: any, tenantId: any, userId: any): Promise<{
        id: string;
        tenantId: any;
        securityId: any;
        calculationDate: Date;
        delta: number;
        gamma: number;
        theta: number;
        vega: number;
        rho: number;
        lambda: any;
        epsilon: any;
        volga: any;
        vanna: any;
        charm: any;
        color: any;
        deltaCash: number;
        gammaCash: number;
        thetaDaily: number;
        vegaPercent: number;
        rhoPercent: number;
        underlyingPrice: any;
        volatility: any;
        riskFreeRate: any;
        dividendYield: any;
        timeToExpiration: number;
        calculationMethod: any;
        calculationTime: number;
        warnings: string[];
    }>;
    calculateBlackScholesGreeks(option: any, S: any, sigma: any, r: any, q: any, T: any): Promise<{
        delta: number;
        gamma: number;
        theta: number;
        vega: number;
        rho: number;
        lambda: number;
        vanna: number;
        charm: number;
        color: number;
        volga: number;
    }>;
    calculateBinomialGreeks(option: any, S: any, sigma: any, r: any, q: any, T: any, steps?: number): Promise<{
        delta: number;
        gamma: number;
        theta: number;
        vega: number;
        rho: number;
    }>;
    calculateMonteCarloGreeks(option: any, S: any, sigma: any, r: any, q: any, T: any, simulations?: number): Promise<{
        delta: number;
        gamma: number;
        theta: number;
        vega: number;
        rho: number;
    }>;
    calculateImpliedVolatility(request: any, tenantId: any, userId: any): Promise<{
        id: string;
        tenantId: any;
        securityId: any;
        analysisDate: Date;
        impliedVolatility: any;
        historicalVolatility: any;
        ivRank: any;
        ivPercentile: number;
        atmIV: any;
        skew: any;
        termStructure: any;
        ivStandardDeviation: any;
        confidence95Upper: any;
        confidence95Lower: number;
        dataPoints: any;
        calculationMethod: string;
    }>;
    buildOptionStrategy(request: any, tenantId: any, userId: any): Promise<{
        id: string;
        tenantId: any;
        portfolioId: any;
        strategyName: any;
        strategyType: any;
        description: any;
        legs: any[];
        maxProfit: any;
        maxLoss: any;
        breakeven: any;
        probabilityOfProfit: any;
        netDelta: any;
        netGamma: any;
        netTheta: any;
        netVega: any;
        netRho: any;
        netPremium: any;
        marginRequirement: any;
        buyingPower: any;
        riskRewardRatio: any;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
    }>;
    calculateMargin(request: any, tenantId: any, userId: any): Promise<{
        id: string;
        requestId: string;
        tenantId: any;
        calculationDate: any;
        initialMargin: any;
        maintenanceMargin: any;
        variationMargin: any;
        positionMargins: any[];
        portfolioMargin: any;
        netLiquidationValue: any;
        excessLiquidity: number;
        portfolioRisk: any;
        concentrationRisk: any;
        liquidityRisk: any;
        spanMargin: any;
        calculationMethod: string;
        warnings: any;
    }>;
    calculateMarkToMarket(securityId: any, tenantId: any, userId: any): Promise<{
        id: string;
        tenantId: any;
        instrumentId: any;
        valuationDate: Date;
        marketPrice: any;
        theoreticalPrice: any;
        intrinsicValue: any;
        timeValue: number;
        unrealizedPnL: number;
        dailyPnL: number;
        inceptionPnL: number;
        deltaPnL: any;
        gammaPnL: any;
        thetaPnL: any;
        vegaPnL: any;
        rhoPnL: any;
        residualPnL: number;
        underlyingPrice: any;
        volatility: any;
        riskFreeRate: number;
        timeToExpiration: number;
        pricingModel: DerivativesAnalytics_1.VolatilityModel;
        confidence: number;
        dataSource: string;
        calculationTime: number;
        warnings: any[];
    }>;
    calculatePortfolioAnalytics(portfolioId: any, tenantId: any, userId: any): Promise<{
        id: string;
        tenantId: any;
        portfolioId: any;
        analysisDate: Date;
        totalPositions: any;
        totalNotional: any;
        totalMarketValue: any;
        optionsAllocation: any;
        futuresAllocation: any;
        otherDerivativesAllocation: any;
        portfolioDelta: any;
        portfolioGamma: any;
        portfolioTheta: any;
        portfolioVega: any;
        portfolioRho: any;
        portfolioVaR: any;
        maxDrawdown: any;
        sharpeRatio: any;
        activeStrategies: any;
        strategyBreakdown: any;
        totalMarginUsed: any;
        availableMargin: any;
        marginUtilization: any;
        nearTermExpirations: any;
        totalReturn: any;
        dailyPnL: any;
        monthlyPnL: any;
        yearToDatePnL: any;
        lastUpdated: Date;
        dataQuality: any;
        warnings: any;
    }>;
    searchDerivatives(request: any, tenantId: any): Promise<{
        instruments: any;
        total: any;
        aggregateMetrics: any;
        pagination: {
            limit: any;
            offset: any;
            hasMore: boolean;
        };
    }>;
    normalCDF(x: any): number;
    normalPDF(x: any): number;
    erf(x: any): number;
    calculateTimeToExpiration(expirationDate: any, currentDate: any): number;
    calculateOptionPrice(option: any, S: any, sigma: any, r: any, q: any, T: any): number;
    generateId(): string;
    getDerivativeInstrument(securityId: any, tenantId: any): Promise<any>;
    getRiskFreeRate(currency: any): Promise<number>;
    storeGreeksCalculation(greeks: any): Promise<void>;
    publishGreeksCalculatedEvent(greeks: any, userId: any): Promise<void>;
    publishImpliedVolatilityEvent(analysis: any, userId: any): Promise<void>;
    publishStrategyCreatedEvent(strategy: any, userId: any): Promise<void>;
    publishPortfolioAnalyticsEvent(analytics: any, userId: any): Promise<void>;
    buildBinomialPriceTree(S: any, u: any, d: any, steps: any): any[][];
    buildBinomialOptionTree(option: any, priceTree: any, r: any, dt: any, p: any, steps: any): any[][];
    buildBinomialOptionTreeWithTime(option: any, S: any, sigma: any, r: any, q: any, T: any, steps: any): any;
    buildBinomialOptionTreeWithVol(option: any, S: any, sigma: any, r: any, q: any, T: any, steps: any): any;
    buildBinomialOptionTreeWithRate(option: any, S: any, sigma: any, r: any, q: any, T: any, steps: any): any;
}
import DerivativesAnalytics_1 = require("../models/derivatives/DerivativesAnalytics");
