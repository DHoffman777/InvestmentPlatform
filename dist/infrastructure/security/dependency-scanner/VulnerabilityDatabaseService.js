"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityDatabaseService = void 0;
const events_1 = require("events");
class VulnerabilityDatabaseService extends events_1.EventEmitter {
    databases = new Map();
    vulnerabilityCache = new Map();
    scanReports = new Map();
    rateLimiters = new Map();
    constructor() {
        super();
        this.initializeDefaultDatabases();
    }
    initializeDefaultDatabases() {
        // National Vulnerability Database (NVD)
        this.databases.set('nvd', {
            name: 'National Vulnerability Database',
            url: 'https://services.nvd.nist.gov/rest/json/cves/2.0',
            rateLimitPerMinute: 50,
            supportedEcosystems: ['npm', 'maven', 'pypi', 'rubygems', 'nuget', 'go', 'cargo']
        });
        // GitHub Security Advisory Database
        this.databases.set('ghsa', {
            name: 'GitHub Security Advisories',
            url: 'https://api.github.com/graphql',
            rateLimitPerMinute: 5000,
            supportedEcosystems: ['npm', 'maven', 'pip', 'rubygems', 'nuget', 'go', 'cargo', 'composer']
        });
        // OSV Database
        this.databases.set('osv', {
            name: 'Open Source Vulnerabilities',
            url: 'https://api.osv.dev/v1',
            rateLimitPerMinute: 1000,
            supportedEcosystems: ['npm', 'PyPI', 'Go', 'Packagist', 'Maven', 'NuGet', 'RubyGems', 'crates.io']
        });
        // Snyk Database
        this.databases.set('snyk', {
            name: 'Snyk Vulnerability Database',
            url: 'https://snyk.io/api/v1',
            rateLimitPerMinute: 100,
            supportedEcosystems: ['npm', 'maven', 'pip', 'rubygems', 'nuget', 'go', 'cargo']
        });
        // Sonatype OSS Index
        this.databases.set('sonatype', {
            name: 'Sonatype OSS Index',
            url: 'https://ossindex.sonatype.org/api/v3',
            rateLimitPerMinute: 100,
            supportedEcosystems: ['npm', 'maven', 'pypi', 'rubygems', 'nuget', 'go', 'cargo']
        });
    }
    async scanDependencies(dependencies, inventoryId, options = {}) {
        const scanId = this.generateScanId();
        const startTime = Date.now();
        const errors = [];
        const matches = [];
        try {
            this.emit('scanStarted', { scanId, inventoryId, dependencyCount: dependencies.length });
            const filteredDeps = options.includeTransitive !== false
                ? dependencies
                : dependencies.filter(d => d.type === 'direct');
            const databasesToUse = options.databases || ['osv', 'ghsa', 'nvd'];
            const maxConcurrency = options.maxConcurrency || 10;
            // Process dependencies in batches
            const batches = this.chunkArray(filteredDeps, maxConcurrency);
            for (const batch of batches) {
                const batchPromises = batch.map(async (dependency) => {
                    try {
                        const vulns = await this.scanDependency(dependency, databasesToUse);
                        const depMatches = vulns.map(vuln => this.createVulnerabilityMatch(vuln, dependency));
                        matches.push(...depMatches);
                        this.emit('dependencyScanned', {
                            dependency: dependency.name,
                            vulnerabilities: vulns.length
                        });
                    }
                    catch (error) {
                        errors.push(`Error scanning ${dependency.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
                        this.emit('dependencyError', {
                            dependency: dependency.name,
                            error: error instanceof Error ? error.message : 'Unknown error'
                        });
                    }
                });
                await Promise.all(batchPromises);
                // Small delay between batches to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            // Filter by severity threshold if specified
            const filteredMatches = options.severityThreshold
                ? this.filterBySeverity(matches, options.severityThreshold)
                : matches;
            const report = {
                scanId,
                inventoryId,
                totalDependencies: filteredDeps.length,
                vulnerableDependencies: new Set(filteredMatches.map(m => m.dependency.name)).size,
                totalVulnerabilities: filteredMatches.length,
                severityBreakdown: this.calculateSeverityBreakdown(filteredMatches),
                matches: filteredMatches,
                scanDuration: Date.now() - startTime,
                completedAt: new Date(),
                databasesUsed: databasesToUse,
                errors
            };
            this.scanReports.set(scanId, report);
            this.emit('scanCompleted', {
                scanId,
                vulnerabilities: report.totalVulnerabilities,
                criticalCount: report.severityBreakdown.CRITICAL || 0
            });
            return report;
        }
        catch (error) {
            this.emit('scanFailed', { scanId, inventoryId, error: error instanceof Error ? error.message : 'Unknown error' });
            throw error;
        }
    }
    async scanDependency(dependency, databases) {
        const vulnerabilities = [];
        for (const dbName of databases) {
            const db = this.databases.get(dbName);
            if (!db || !db.supportedEcosystems.includes(dependency.ecosystem)) {
                continue;
            }
            try {
                await this.enforceRateLimit(dbName, db.rateLimitPerMinute);
                const cacheKey = `${dbName}:${dependency.ecosystem}:${dependency.name}:${dependency.version}`;
                let dbVulns = this.vulnerabilityCache.get(cacheKey);
                if (!dbVulns) {
                    dbVulns = await this.queryDatabase(db, dependency);
                    this.vulnerabilityCache.set(cacheKey, dbVulns);
                    // Cache for 1 hour
                    setTimeout(() => this.vulnerabilityCache.delete(cacheKey), 3600000);
                }
                vulnerabilities.push(...dbVulns);
            }
            catch (error) {
                console.warn(`Failed to query ${dbName} for ${dependency.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
                continue;
            }
        }
        // Deduplicate vulnerabilities by CVE/ID
        return this.deduplicateVulnerabilities(vulnerabilities);
    }
    async queryDatabase(database, dependency) {
        switch (database.name) {
            case 'Open Source Vulnerabilities':
                return await this.queryOSVDatabase(dependency);
            case 'GitHub Security Advisories':
                return await this.queryGHSADatabase(dependency);
            case 'National Vulnerability Database':
                return await this.queryNVDDatabase(dependency);
            case 'Snyk Vulnerability Database':
                return await this.querySnykDatabase(dependency);
            case 'Sonatype OSS Index':
                return await this.querySonatypeDatabase(dependency);
            default:
                return [];
        }
    }
    async queryOSVDatabase(dependency) {
        try {
            const ecosystemMap = {
                'npm': 'npm',
                'python': 'PyPI',
                'java': 'Maven',
                'dotnet': 'NuGet',
                'ruby': 'RubyGems',
                'go': 'Go',
                'rust': 'crates.io'
            };
            const ecosystem = ecosystemMap[dependency.ecosystem];
            if (!ecosystem)
                return [];
            const response = await fetch('https://api.osv.dev/v1/query', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    package: {
                        ecosystem,
                        name: dependency.name
                    },
                    version: dependency.version !== '*' ? dependency.version : undefined
                })
            });
            if (!response.ok)
                return [];
            const data = await response.json();
            return this.parseOSVResponse(data, dependency);
        }
        catch (error) {
            console.error(`OSV query failed for ${dependency.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return [];
        }
    }
    parseOSVResponse(data, dependency) {
        if (!data.vulns)
            return [];
        return data.vulns.map((vuln) => ({
            id: vuln.id,
            cve: vuln.aliases?.find((alias) => alias.startsWith('CVE-')),
            osvId: vuln.id,
            title: vuln.summary || `Vulnerability in ${dependency.name}`,
            description: vuln.details || vuln.summary || '',
            severity: this.mapSeverity(vuln.database_specific?.severity || 'MEDIUM'),
            cvssScore: vuln.database_specific?.cvss_score,
            packageName: dependency.name,
            ecosystem: dependency.ecosystem,
            affectedVersions: this.parseVersionRanges(vuln.affected?.[0]?.ranges || []),
            patchedVersions: this.parseVersionRanges(vuln.affected?.[0]?.fixed || []),
            publishedAt: new Date(vuln.published || Date.now()),
            updatedAt: new Date(vuln.modified || vuln.published || Date.now()),
            references: vuln.references?.map((ref) => ({
                type: 'WEB',
                url: ref.url,
                source: ref.type
            })) || [],
            advisories: [],
            fixAvailable: (vuln.affected?.[0]?.fixed || []).length > 0,
            dataSource: 'OSV',
            lastChecked: new Date()
        }));
    }
    async queryGHSADatabase(dependency) {
        try {
            const ecosystemMap = {
                'npm': 'NPM',
                'python': 'PIP',
                'java': 'MAVEN',
                'dotnet': 'NUGET',
                'ruby': 'RUBYGEMS',
                'go': 'GO',
                'rust': 'CARGO'
            };
            const ecosystem = ecosystemMap[dependency.ecosystem];
            if (!ecosystem)
                return [];
            const query = `
        query($packageName: String!, $ecosystem: SecurityAdvisoryEcosystem!) {
          securityVulnerabilities(
            first: 100,
            package: $packageName,
            ecosystem: $ecosystem
          ) {
            nodes {
              advisory {
                ghsaId
                cvss {
                  score
                  vectorString
                }
                severity
                summary
                description
                publishedAt
                updatedAt
                references {
                  url
                }
                cwes(first: 10) {
                  nodes {
                    cweId
                  }
                }
              }
              vulnerableVersionRange
              firstPatchedVersion {
                identifier
              }
            }
          }
        }
      `;
            const response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`
                },
                body: JSON.stringify({
                    query,
                    variables: {
                        packageName: dependency.name,
                        ecosystem
                    }
                })
            });
            if (!response.ok)
                return [];
            const data = await response.json();
            return this.parseGHSAResponse(data, dependency);
        }
        catch (error) {
            console.error(`GHSA query failed for ${dependency.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return [];
        }
    }
    parseGHSAResponse(data, dependency) {
        if (!data.data?.securityVulnerabilities?.nodes)
            return [];
        return data.data.securityVulnerabilities.nodes.map((node) => {
            const advisory = node.advisory;
            return {
                id: advisory.ghsaId,
                ghsa: advisory.ghsaId,
                title: advisory.summary || `Vulnerability in ${dependency.name}`,
                description: advisory.description || advisory.summary || '',
                severity: this.mapSeverity(advisory.severity),
                cvssScore: advisory.cvss?.score,
                cvssVector: advisory.cvss?.vectorString,
                cwe: advisory.cwes?.nodes?.map((cwe) => cwe.cweId) || [],
                packageName: dependency.name,
                ecosystem: dependency.ecosystem,
                affectedVersions: this.parseGHSAVersionRange(node.vulnerableVersionRange),
                patchedVersions: node.firstPatchedVersion ? [{
                        operator: '>=',
                        version: node.firstPatchedVersion.identifier
                    }] : [],
                publishedAt: new Date(advisory.publishedAt),
                updatedAt: new Date(advisory.updatedAt),
                references: advisory.references?.map((ref) => ({
                    type: 'WEB',
                    url: ref.url
                })) || [],
                advisories: [{
                        id: advisory.ghsaId,
                        source: 'GitHub',
                        severity: advisory.severity,
                        summary: advisory.summary
                    }],
                fixAvailable: !!node.firstPatchedVersion,
                dataSource: 'GHSA',
                lastChecked: new Date()
            };
        });
    }
    async queryNVDDatabase(dependency) {
        try {
            // NVD requires CPE matching which is complex for package names
            // This is a simplified implementation
            const response = await fetch(`https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodeURIComponent(dependency.name)}&resultsPerPage=50`);
            if (!response.ok)
                return [];
            const data = await response.json();
            return this.parseNVDResponse(data, dependency);
        }
        catch (error) {
            console.error(`NVD query failed for ${dependency.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return [];
        }
    }
    parseNVDResponse(data, dependency) {
        if (!data.vulnerabilities)
            return [];
        return data.vulnerabilities
            .filter((item) => {
            // Basic filtering to match package name in description
            const description = item.cve?.descriptions?.[0]?.value?.toLowerCase() || '';
            return description.includes(dependency.name.toLowerCase());
        })
            .map((item) => {
            const cve = item.cve;
            const metrics = cve.metrics?.cvssMetricV31?.[0] || cve.metrics?.cvssMetricV30?.[0];
            return {
                id: cve.id,
                cve: cve.id,
                title: `${cve.id} in ${dependency.name}`,
                description: cve.descriptions?.[0]?.value || '',
                severity: this.mapCVSSSeverity(metrics?.cvssData?.baseScore || 0),
                cvssScore: metrics?.cvssData?.baseScore,
                cvssVector: metrics?.cvssData?.vectorString,
                cwe: cve.weaknesses?.map((w) => w.description?.[0]?.value).filter(Boolean) || [],
                packageName: dependency.name,
                ecosystem: dependency.ecosystem,
                affectedVersions: [],
                patchedVersions: [],
                publishedAt: new Date(cve.published),
                updatedAt: new Date(cve.lastModified),
                references: cve.references?.map((ref) => ({
                    type: 'WEB',
                    url: ref.url,
                    source: ref.source
                })) || [],
                advisories: [],
                fixAvailable: false,
                dataSource: 'NVD',
                lastChecked: new Date()
            };
        });
    }
    async querySnykDatabase(dependency) {
        // Snyk requires API key and specific endpoints
        // This is a placeholder implementation
        return [];
    }
    async querySonatypeDatabase(dependency) {
        try {
            const coordinate = this.buildSonatypeCoordinate(dependency);
            if (!coordinate)
                return [];
            const response = await fetch('https://ossindex.sonatype.org/api/v3/component-report', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    coordinates: [coordinate]
                })
            });
            if (!response.ok)
                return [];
            const data = await response.json();
            return this.parseSonatypeResponse(data, dependency);
        }
        catch (error) {
            console.error(`Sonatype query failed for ${dependency.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return [];
        }
    }
    buildSonatypeCoordinate(dependency) {
        const coordMap = {
            'npm': (dep) => `pkg:npm/${dep.name}@${dep.version}`,
            'python': (dep) => `pkg:pypi/${dep.name}@${dep.version}`,
            'java': (dep) => `pkg:maven/${dep.name}@${dep.version}`,
            'dotnet': (dep) => `pkg:nuget/${dep.name}@${dep.version}`,
            'ruby': (dep) => `pkg:gem/${dep.name}@${dep.version}`,
            'go': (dep) => `pkg:golang/${dep.name}@${dep.version}`,
            'rust': (dep) => `pkg:cargo/${dep.name}@${dep.version}`
        };
        const builder = coordMap[dependency.ecosystem];
        return builder ? builder(dependency) : null;
    }
    parseSonatypeResponse(data, dependency) {
        if (!data?.[0]?.vulnerabilities)
            return [];
        return data[0].vulnerabilities.map((vuln) => ({
            id: vuln.id,
            cve: vuln.cve,
            title: vuln.title || `Vulnerability in ${dependency.name}`,
            description: vuln.description || '',
            severity: this.mapCVSSSeverity(vuln.cvssScore || 0),
            cvssScore: vuln.cvssScore,
            cvssVector: vuln.cvssVector,
            cwe: vuln.cwe ? [vuln.cwe] : [],
            packageName: dependency.name,
            ecosystem: dependency.ecosystem,
            affectedVersions: [],
            patchedVersions: [],
            publishedAt: new Date(),
            updatedAt: new Date(),
            references: vuln.reference ? [{
                    type: 'WEB',
                    url: vuln.reference
                }] : [],
            advisories: [],
            fixAvailable: false,
            dataSource: 'Sonatype',
            lastChecked: new Date()
        }));
    }
    deduplicateVulnerabilities(vulnerabilities) {
        const seen = new Set();
        const deduplicated = [];
        for (const vuln of vulnerabilities) {
            const key = vuln.cve || vuln.ghsa || vuln.osvId || vuln.id;
            if (!seen.has(key)) {
                seen.add(key);
                deduplicated.push(vuln);
            }
        }
        return deduplicated;
    }
    createVulnerabilityMatch(vulnerability, dependency) {
        const isAffected = this.isVersionAffected(dependency.version, vulnerability.affectedVersions);
        const fixAvailable = vulnerability.patchedVersions.length > 0;
        return {
            vulnerability,
            dependency,
            matchType: 'VERSION_RANGE',
            confidence: isAffected ? 0.9 : 0.5,
            matchedVersion: dependency.version,
            fixAvailable,
            recommendedAction: this.determineRecommendedAction(vulnerability, dependency, fixAvailable),
            context: {
                directImpact: dependency.type === 'direct',
                runtimeReachable: undefined
            }
        };
    }
    isVersionAffected(version, affectedRanges) {
        if (version === '*' || affectedRanges.length === 0)
            return true;
        // Simplified version checking - in production, use semver library
        for (const range of affectedRanges) {
            if (this.compareVersions(version, range.version, range.operator)) {
                return true;
            }
        }
        return false;
    }
    compareVersions(version1, version2, operator) {
        // Simplified version comparison - in production, use proper semver comparison
        const v1Parts = version1.split('.').map(Number);
        const v2Parts = version2.split('.').map(Number);
        for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
            const v1Part = v1Parts[i] || 0;
            const v2Part = v2Parts[i] || 0;
            if (v1Part !== v2Part) {
                switch (operator) {
                    case '<': return v1Part < v2Part;
                    case '<=': return v1Part <= v2Part;
                    case '>': return v1Part > v2Part;
                    case '>=': return v1Part >= v2Part;
                    case '=': return v1Part === v2Part;
                    case '!=': return v1Part !== v2Part;
                    default: return false;
                }
            }
        }
        return operator === '=' || operator === '<=' || operator === '>=';
    }
    determineRecommendedAction(vulnerability, dependency, fixAvailable) {
        if (vulnerability.severity === 'CRITICAL') {
            return fixAvailable ? 'UPDATE' : 'REPLACE';
        }
        else if (vulnerability.severity === 'HIGH') {
            return fixAvailable ? 'UPDATE' : 'MONITOR';
        }
        else if (vulnerability.severity === 'MEDIUM') {
            return fixAvailable ? 'PATCH' : 'MONITOR';
        }
        else {
            return 'MONITOR';
        }
    }
    parseVersionRanges(ranges) {
        if (!Array.isArray(ranges))
            return [];
        return ranges.map(range => ({
            operator: range.type || '<',
            version: range.version || range,
            inclusive: range.inclusive
        }));
    }
    parseGHSAVersionRange(rangeString) {
        if (!rangeString)
            return [];
        // Parse GitHub Security Advisory version range format
        // e.g., "< 1.2.3", ">= 1.0.0, < 2.0.0"
        const ranges = [];
        const parts = rangeString.split(',').map(p => p.trim());
        for (const part of parts) {
            const match = part.match(/^([<>=!]+)\s*(.+)$/);
            if (match) {
                ranges.push({
                    operator: match[1],
                    version: match[2]
                });
            }
        }
        return ranges;
    }
    mapSeverity(severity) {
        const normalized = severity.toUpperCase();
        if (['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'].includes(normalized)) {
            return normalized;
        }
        return 'MEDIUM';
    }
    mapCVSSSeverity(score) {
        if (score >= 9.0)
            return 'CRITICAL';
        if (score >= 7.0)
            return 'HIGH';
        if (score >= 4.0)
            return 'MEDIUM';
        if (score > 0)
            return 'LOW';
        return 'INFO';
    }
    filterBySeverity(matches, threshold) {
        const severityOrder = ['INFO', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
        const thresholdIndex = severityOrder.indexOf(threshold.toUpperCase());
        if (thresholdIndex === -1)
            return matches;
        return matches.filter(match => {
            const matchIndex = severityOrder.indexOf(match.vulnerability.severity);
            return matchIndex >= thresholdIndex;
        });
    }
    calculateSeverityBreakdown(matches) {
        const breakdown = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
            INFO: 0
        };
        for (const match of matches) {
            breakdown[match.vulnerability.severity]++;
        }
        return breakdown;
    }
    async enforceRateLimit(dbName, limitPerMinute) {
        const now = Date.now();
        const limiter = this.rateLimiters.get(dbName) || { requests: 0, resetTime: now + 60000 };
        if (now > limiter.resetTime) {
            limiter.requests = 0;
            limiter.resetTime = now + 60000;
        }
        if (limiter.requests >= limitPerMinute) {
            const waitTime = limiter.resetTime - now;
            await new Promise(resolve => setTimeout(resolve, waitTime));
            limiter.requests = 0;
            limiter.resetTime = Date.now() + 60000;
        }
        limiter.requests++;
        this.rateLimiters.set(dbName, limiter);
    }
    chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }
    generateScanId() {
        return `vuln_scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    // Public API methods
    getScanReport(scanId) {
        return this.scanReports.get(scanId);
    }
    getVulnerabilityById(vulnerabilityId) {
        for (const vulnerabilities of this.vulnerabilityCache.values()) {
            const found = vulnerabilities.find(v => v.id === vulnerabilityId);
            if (found)
                return found;
        }
        return undefined;
    }
    async refreshVulnerabilityData(packageName, ecosystem) {
        const cacheKeys = Array.from(this.vulnerabilityCache.keys())
            .filter(key => key.includes(`${ecosystem}:${packageName}`));
        for (const key of cacheKeys) {
            this.vulnerabilityCache.delete(key);
        }
    }
    getRecentScans(limit = 10) {
        return Array.from(this.scanReports.values())
            .sort((a, b) => b.completedAt.getTime() - a.completedAt.getTime())
            .slice(0, limit);
    }
    getScanMetrics() {
        const reports = Array.from(this.scanReports.values());
        const totalScans = reports.length;
        const totalVulnerabilities = reports.reduce((sum, r) => sum + r.totalVulnerabilities, 0);
        const avgScanDuration = reports.reduce((sum, r) => sum + r.scanDuration, 0) / totalScans;
        const severityTotals = reports.reduce((acc, report) => {
            Object.entries(report.severityBreakdown).forEach(([severity, count]) => {
                acc[severity] = (acc[severity] || 0) + count;
            });
            return acc;
        }, {});
        return {
            totalScans,
            totalVulnerabilities,
            avgScanDuration: Math.round(avgScanDuration),
            severityBreakdown: severityTotals,
            databaseUsage: this.getDatabaseUsageStats()
        };
    }
    getDatabaseUsageStats() {
        const usage = {};
        for (const report of this.scanReports.values()) {
            for (const db of report.databasesUsed) {
                usage[db] = (usage[db] || 0) + 1;
            }
        }
        return usage;
    }
}
exports.VulnerabilityDatabaseService = VulnerabilityDatabaseService;
