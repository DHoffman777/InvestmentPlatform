import { EventEmitter } from 'events';
import { ResourceMetric, ResourceUtilizationSnapshot, ResourceDataSource } from './ResourceDataModel';
export interface ResourceCollectionConfig {
    refreshInterval: number;
    batchSize: number;
    maxRetries: number;
    timeoutMs: number;
    enableRealTimeStreaming: boolean;
    enableQualityValidation: boolean;
    dataRetentionHours: number;
    aggregationWindows: number[];
}
export declare class ResourceUtilizationService extends EventEmitter {
    private config;
    private metrics;
    private snapshots;
    private dataSources;
    private collections;
    private qualityValidators;
    constructor(config: ResourceCollectionConfig);
    addDataSource(dataSource: ResourceDataSource): Promise<any>;
    removeDataSource(dataSourceId: string): Promise<any>;
    collectMetrics(resourceIds?: string[]): Promise<ResourceMetric[]>;
    private collectResourceMetrics;
    private collectPrometheusMetrics;
    private collectCloudWatchMetrics;
    private collectKubernetesMetrics;
    private collectDockerMetrics;
    private collectSystemMetrics;
    private collectCustomMetrics;
    generateSnapshot(resourceId: string): Promise<ResourceUtilizationSnapshot>;
    private calculateUtilization;
    private assessResourceHealth;
    private analyzeCapacity;
    private analyzeTrends;
    private detectAnomalies;
    private generateMetricId;
    private generateSnapshotId;
    private executePrometheusQuery;
    private executeCloudWatchQuery;
    private executeKubernetesQuery;
    private executeDockerStatsQuery;
    private collectSystemMetric;
    private executeCustomQuery;
    private inferResourceType;
    private getMetricUnit;
    private extractDimensions;
    private storeMetrics;
    private storeSnapshot;
    private startCollectionScheduler;
    private setupQualityValidators;
    private validateDataSource;
    private validateMetrics;
    private getRecentMetrics;
    private calculateAverageUtilization;
    private calculateNetworkUtilization;
    private calculatePercentile;
    private determineTrend;
    private calculateHealthScore;
    private determineHealthStatus;
    private calculateAvailabilityScore;
    private calculatePerformanceScore;
    private calculateErrorScore;
    private calculateCapacityScore;
    private identifyHealthIssues;
    private calculateTotalCapacity;
    private calculateUsedCapacity;
    private calculateAvailableCapacity;
    private calculateReservedCapacity;
    private getSoftLimits;
    private getHardLimits;
    private getConfiguredLimits;
    private getTheoreticalLimits;
    private forecastCapacity;
    private analyzeTrendPeriod;
    private getHistoricalMetrics;
    private detectMetricAnomaly;
    private calculateEfficiency;
    private generateRecommendations;
    shutdown(): Promise<any>;
}
